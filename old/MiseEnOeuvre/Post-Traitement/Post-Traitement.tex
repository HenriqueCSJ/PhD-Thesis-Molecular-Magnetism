\chapter{Le post-traitement}

Lorsque j'ai commencé à traiter les données issues de nos mesures, j'ai du faire face à un problème concernant la taille des fichiers générés. En effet, la grande majorité des mesures faites consiste en une série répétée d'aller-retour en champ magnétique. Pour les études fines du spin nucléaire qui seront présenté dans la suite, il a fallu effectuer 10000 aller-retour en champ et traiter 20000 mesures consitué de 1700 points chacune soit au total 34 millions de points. A partir de ces données, il fallait pour chaque balayage vérifier la présence de saut dans la mesure de conductance et relever ça position. Il fallait ensuite trouver un moyen clair de representer d'eventuelles coherences dans la position de ces sauts de conductances.

Il s'agissait donc de trouver un moyen efficace d'analyser l'ensemble de ces mesures mais aussi et surtout de les convertir dans un format plus facile à manipuler pour une analyse plus facile. J'ai donc décidé de ne pas utiliser les logiciels habituels type MatLab ou Igor mais de me tourner vers un langage de programmation objet : le langage Python. Dans ce chapitre, je justifierai d'abord ce choix. Je montrerai ensuite comment grace à la souplesse de la programmation objet j'ai mis au point une méthode afin de détecter les sauts de conductance et de représenter les données de façon exploitable.


\section{Les type de langage}
Dans une classification simplifié, on peut identifié deux classes de langage : les langages compilés et les langages interprétés. Par exemple, le langage C appartient aux langages compilé. Cela signifie que le progamme contenue dans un fichier .c ne peut pas être directement utilisé mais doit être compilé afin de produire un fichier binaire qui lui pourra être utiliser. Les avantages et inconvénients de ce type de langage sera détaillé dans la suite. Le javascript très utiliser dans le monde internet est lui un langage interprété. Un fichier javascript est directement utiliser car il est ``lu'' et ``interprété'' directement par l'odinateur ou plus précisement par l'interpreteur. Les avantages de ce type de langage sera abordé dans la deuxième partie de cette section.

\subsection{Compilé}
Un programme issue d'un langage compilé est obtenue en plusieurs étapes. Dans une vue très schématique, tout d'abord le programme est écrite dans un langage approprié comme par exemple C. Un fois le programme terminé, les fichiers sources sont compilés et un fichier binaire est crée. Ce fichier contient du langage machine qui peut directement être lu par l'ordinateur. Au vu de cette procédure, il est facile d'identifier les deux principaux désavantages des langages compilés. Premièrement, si une modification est apporté au code source, il faut à nouveau recompilé avant de pouvoir utiliser les fonctions qui viennent d'être ajouté. Cela peut vite devenir fastidieux si ces modifications sont fréquentes. Deuxième inconvénient, le programme binaire obtenu est spécifique au système d'exploitation (Linux, Windows, Mac etc..) mais égalemelent dépend de l'architecture du processeur (32bit/64bit etc..). Il faut donc recompiler le code source à chaque fois que l'on change de système d'exploitation par exemple. Dans notre groupe, les ordinateurs de mesures sont sous Windows alors que certain chercheurs travailles sous Windows. Il faudrait donc compiler la library au moins deux fois et ceci chaque fois qu'une modification est apporté à la bilbiothèque. Ceci rendrait les évolutions et mises à jour fastidieuses et ne convient pas réellement au besoin changeant que sont les notres. 

\subsection{Interprété}
Un langage interpréte fonctionne différement. Un programme écrit dans ce type de langage n'a pas besoin de passer par un compilateur. Il va être analyser par un interpreteur qui va se charger ensuite de traduire le code dans un langage intermédiaire pour accélerer ses futures excécutions et il va ensuite effectuer les opérations programmées. Un des grands avantages de cette solution est la réactivité de la procédure, car une modification du fichier source est immédiatement prise lors de le réexecution du programme. En revanche, les programmes conçu en langae interprété sont de façon générale beaucoup plus lent et des facteur de 1 à 100 ne sont pas impossible entre deux opération similaire l'une étant issue d'un code compilé et l'autre d'un code interprété.

\section{Le bon compromis : Python}
Comme c'est le cas en général, la bonne solution ne consiste pas à choisir l'un ou l'autre des ses langage mais plutot de trouver la bonne façon de les combinés. Autrement dit, il faut que les opérations qui prennent le plus de temps soit effectué à l'aide d'un langage compilé pendant que celle qui demande peut de ressource peuvent être programmé à l'aide d'un langage interprété. L'inconvénient de cette dernier choix est qu'il faut en général utitiser deux langages très différents et les faire interagir. Afin de contourner cette difficulté, j'ai décidé de me tourner vers un langage qui permet de faciliter cette interface à savoir le Python. Grace à un langage qui en est dérivé, il est possible de façon très simple de faire l'interface entre les deux mondes. Je vais dans la suite vous décrire en détails les avantages de ce langage et la façon dont on peut le liée avec un langage compilé comme le C.

\subsection{Python}
Le Python est un langage apparu au début des années 90. Etant très souple et facile à apprendre, il gagne rapidement en popularité et devient un des langage référence dans le domaine scientifique. Il dispose aujourd'hui d'une grande communauté d'utilisateur qui ont développé un très grand nombre de bibliothèque. Ces différentes qualité en font un langage très adapté à l'analyse de donnée. Pour ce qui est des fonctions mathématique usuelle, les bilbiothèque numoy et scipy fournissent tous les outils nécéssaire. Le tracé des fonctions 2D est assuré par la biliothèque matplotlib, riche et qui fournit des figures d'une grande qualité. Les grahique 3D quand à eux sont obtenue à l'aide de Mayavi2, une puissante librairie de tracé 3D. Cette ensemble permet de traité les données dans un seul et même environement. Comme je le précisais plus haut, un des inconvénient des langages interprétés est leur vitesse d'exécution. Dans le cas des fonction mathématique des bilbiothèque présenté plus haut, cela ne pose pas vraimenbt de problème car elle sont en fait écrirt en C et s'exécute donc très rapidement. En revanche, pour le fonctions relativement complexe qu'un utilisateur lambda veut implémenter, cette lenteur peut devenir un problème. C'est ici qu'un langage dérivé du Python, le Cython intervient.

\subsection{Cython}
C'est un langage beaucoup plus récent puisqu'il est apparu au cours de l'année 2007.Il est en fait conçu pour faciliter l'interfaçage, ou autrement dit le dialogue, entre le langage Python et le langage C/C++. La syntaxe est très proche de celle du Pyhton et un programme en Python peut être directement compilé sans aucune modification même si dans ce cas le gain de performance est limité. Cette similarité offre un avantage de taille. Il est possible de développer une fonction en lanageg Python avec un cycle rapide code source/exécution puis de la traduire en Cython en vue de meilleure performance. Ene effet, passer d'un code Python à un code Cython performant consiste principalement à typé les objects, c'est à dire, à préciser le contenue de ces object ; i.e un entier, un double etc.. 

\subsection{Une histoire de combinaison}
Un fois ces deux outils à notre disposition, il a fallu choisir ce qui serait fait en Python et ce qui devrait être programmé en utilisant Cython. En essayant de déterminer les fonctions les plus exigeante, il a été facile de déterminer les deux opérations demandant le plus de temps de calculs. Il s'agissait de la moyenne glissé et la fonctions recherche des minimum locaux. Les autre fonctions conssitant à exploiter les résultats des deux fonctions précédentes étant très peu gourmande en ressource, elle on été écrite en Pyhton. Cette combinaison permter d'avoir un code qui bénéficie de la vitesse du langage compilé pour ce qui est de la moyenne glissée et du détecteur de miminum locaux tout en tirant avantage de la souplesse du Python. L'inconvénient est qu'il faut compilé au moins une fois les deux fonctions Cython. Mais leur définition a peu de chance de changer et la majeure partie du programme peu changer sans que une nouvelle compilation ne soit nécessaire.


\section{Méthode : l'objet {\it CycleProcess}}
Mainetant que nous disposons d'outils numérique suffisament souple et performant, je vais pouvoir décrire la méthode que nous avons utilisé pour extraire la position des sauts dans nos mesure de conductance et comment nous avons pu analyser les correlations entre ces différents sauts. Plus de détails sur l'ensemble des post-traitement effectué sont présenté dans l'annexe. Ce paragraphe n'aborde que les deux technique principale à savoir l'extraction des saut à l'aide d'un filtre numérique et la mesure de la corrélation à l'aide d'histogramme 2D.

\subsection{Le filtre}
Pour des raisons qui seront présentés dans la partie traitant des résultats expérimentaux, un renversement de l'aimantation de l'ion Tb$^{3+}$ se matérialise sous la forme d'une marche lorsque l'on mesure la conductance en fonction du champ magnétique. Une courbe représentative est présenté dans le figure ??. Afin d'extraire de façon automatique la position des marches, nous avons repris une technique utilisé par Romain Maurand pour détecter les transitions d'un nanosquid et inspiré du travail de W.Y. Liu et ses collaborateurs. Le principe de se filter est relativement simple. Il consiste à mesurer l'écart type de la moyenne d'un signal. Lorsque le signal ne varie pas en amplitude, cette variance est proche de zéro. En revanche un singal dont la valeut varie brutalement va avoir un écart type de ça moyenne élevé. Un signal avec deux zones de faible variation séparé par un changement brutal va possédé un écart type de la moyenne null à l'exeception du changement abrupt qui va donné naissance à un pic. Une fois le filtre appliqué, il faut simplement relever la position du peak qui donne la position de la transition.

\subsection{Les histogrammes 2D}
La position des transition à elles seules n'est pas suffisante pour une analyse complète. Il peut être intéressant comme nous le verrons dans la suite, de ``mesurer'' la corrélation entre les différents sauts. Une des manières de représenter cette correlation est de tracer un histogramme en deux dimension. Pour cela, on choisi un plan dont les deux axes sont relatifs à la position des sauts. Un couple de saut peut donc être positionné sur ce plan à l'aide un point de coordonnées (p$_1$,p$_2$), p$_1$ et p$_2$ étant la positions des sauts 1 et deux respectivement. En effectuant plusieurs milliers de mesures de la position du saut, on obtient une collection de couple (p$_1$,p$_2$). On divise ensuite le plan en petit carré d'égale surface et on vient placé les différents couples obtenus. Chaque fois qu'un couple tombe dans un des carré, la hauteur de celui-ci augmente et vient produire des cubes dont la hauteurs est propotionnelle au nombre de couple correspondant a cette partie du plan. La lecture d'un tel histogramme nous donne donc une lecture directe de la correlation entre deux sauts. La figure S1 montre un case pour lequel il y a quatre positions de saut préférentielle, la probabilité étant grande d'avoir deux sauts consécutifs à une même valeur du champ (d'où la prédominance des éléments diagonaux). Nous verrons dans la partie suivante la signification physique de tels histogrammes.


